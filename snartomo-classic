#!/bin/bash

###############################################################################
# SNARTomoClassic performs the following steps for tilt series:
#   1. MotionCor2
#   2. CTFFIND
#   3. Topaz denoising
#   4. _S_orts tilt-series micrographs from lowest tilt (most negative) to highest
#   5. _N_ewstack (from IMOD) to generate a sorted stack 
#   6. _AR_e_TOMO_ to compute reconstruction
#
# Changelog:
#   2023-02-23 (trs) -- MRCs and TIFs supported
#   2023-02-07 (trs) -- can restore previously-processed movies to original location
#   2022-08-12 (trs) -- added JANNI denoising (UNTESTED)
#   2022-05-07 (trs) -- shares functions with SNARTomoPACE
#   2022-03-12 (trs) -- can read pixel size, other info, from MDOC file
#   2022-03-09 (trs) -- added Topaz 2D denoising option
#   2022-02-28 (trs) -- can compute reconstruciton using IMOD instead of AreTomo
#   2022-01-28 (trs) -- writes command line to output directory
#   2021-12-12 (trs) -- added argument-parser
#
###############################################################################

function program_info() {
  echo 
  echo "Running: SNARTomoClassic"
  echo "Modified 2023-07-05"
  date
  echo 
}

function print_usage() {
  echo "USAGE (EER): $(basename $0) --eer_dir <movie_directory> --gain_file <gain_file> <options>"
  echo "DRY RUN:     $(basename $0) --eer_dir <movie_directory> --gain_file <gain_file> <options> --testing"
  echo
  echo "To list options & defaults, type:"
  echo "  $(basename $0) --help"
  echo
  echo "Program expects input tilt series of the form:"
  echo "  {arbitrary_tilt_series_name}_{tiltSeriesIndex}_{angle}_{date}.{format}"
  echo "The arbitrary_tilt_series_name can have underscores, but"
  echo "  tiltSeriesIndex, angle, and date cannot."
  echo
}

function howto_stop() {
  echo "TO END PROCESSING"
  echo "  Program computes a reconstruction of a tilt series when a new tilt series begins."
  echo "  However, the last tilt series will generally not be followed by any additional files."
  echo "  The program will run for the duration set with the parameter 'max_minutes'."
  echo "  To end the program early, create a random movie file in the input directory,"
  echo "    which will start the last reconstruction, e.g.:"
  echo "    touch {movie_dir}/done.{movie_extension}"
  echo
  echo "BEGIN"
}

#################### Filenames ####################

# Inputs
shared_libs=snartomo-shared.bash                   # Shared libraries
log_file=log-snartomo.txt                          # Log file
outdir=SNARTomo                                    # Output top-level directory

#################### Parameters ###################

# General parameters
max_minutes=600                                   # Maximum run time, minutes
apix=-1.00                                        # A/px
gpus="0"                                          # list of GPUs to use, delimited by spaces
verbosity=4                                       # verbosity level
#                                                 #   0: prints nothing
#                                                 #   1: overall summary
#                                                 #   2: prints summary for each tomogram 
#                                                 #   3: prints warnings 
#                                                 #   4: lists each micrograph 
#                                                 #   5: prints commands for each micrograph
#                                                 #   6: prints summary of IMOD & AreTomo info
#                                                 #   7: prints full MotionCor/CTFFIND/IMOD/AreTomo info
#                                                 #   8: extra debug info
dosefit_verbose=6                                 # Verbosity level for dose-fitting log file (0..8)

# MotionCor2
frame_file=motioncor-frame.txt                    # Frames file
reffrm=1                                          # (boolean) reference frame (0: first, 1: middle)
SplitSum=0                                        # (boolean) split frames into even & odd half-sets (1: yes)

# CTFFIND
ctf1d_dpi=250                                     # Resolution (dpi) of PNG of 1D CTF profile
ctfplot_first=-1                                  # Plots first CTF data for first N images in tilt series

#################### Outputs #################### 

cmd_file=commands.txt                             # Output commands file (in ${outdir})
set_file=settings.txt                             # Output settings file (in ${outdir})
rawdir=1-Movies                                   # directory where raw movie files will go
micdir=2-MotionCor2                               # MotionCor directory
mc2_logs=Logs                                     # directory for resource and MotionCor log files
ctfdir=3-CTFFIND4                                 # CTFFIND directory
ctf_summary=SUMMARY_CTF.txt                       # CTFFIND summary
ctf_plot=ctfbyts.png                              # Plot of CTF data by tilt series
denoisedir=4-Denoise                              # Denoised micrograph directory
recdir=5-Tomo                                     # Reconstruction directory
imgdir=Images                                     # Image directory
ts_list=ts_list.txt                               # List of tilt series
thumbdir=Thumbnails                               # Central sections of tomograms
dose_imgdir=DoseFit                               # Dose fitting plot directory
resid_imgdir=Residuals                            # Micrograph removal plot directory
contour_imgdir=Contours                           # Contour removal plot directory
temp_dir=tmp                                      # Temporary files
dir2denoise=TmpDenoised                           # Denoised micrographs will go here
isonet_star=isonet_deconv.star                    # IsoNet STAR file

################ END BATCH HEADER ################

# Outline (multiline comment)
: '
main
  check_env
  parse_command_line
  shared.check_format
  shared.check_args
  shared.check_testing
  do_real_work
    program_info
    print_usage
    print_arguments
    validate_inputs
    initialize_vars
    shared.create_directories
    shared.update_adoc
    check_gain_format
    howto_stop
      LOOP:
        parse_filename
        check_new_tilt_series
          compute_tomogram
            shared.janni_denoise
            shared.topaz_denoise
            shared.write_angles_lists
            shared.imod_restack
            shared.wrapper_aretomo
            shared.wrapper_etomo
        motioncor2_serial
          shared.check_frames
          wait_for_file
          shared.run_motioncor
          remove_local
        ctffind4_serial
        check_time
    summary_info
      shared.clean_local_dir
'

function main() {
  
  # BASH arrays can't returned, so declare them here
  declare -A original_vars
  declare -a var_sequence
  declare -A vars
  
  do_pace=false
  check_env
  parse_command_line "${@}"
  check_format
  check_args 0
  
  # Check if testing
  check_testing
  
  if [[ "${vars[testing]}" == true ]] || [[ "${vars[log]}" == "" ]] || [[ "${verbose}" -eq 0 ]]; then
    if [[ "${verbose}" -ge 1 ]]; then
      echo "Not writing log file"
    fi
    
    do_real_work "${@}"
  else
    if [[ "${verbose}" -ge 1 ]]; then
      echo "Writing to log file: ${vars[log]}"
      do_real_work "${@}" 2>&1 | tee -a "${vars[log]}"
    fi
  fi
}

function do_real_work() {
###############################################################################
#   Function:
#     Does the "real" work
#   
#   Passed arguments:
#     ${@} : command-line arguments
###############################################################################

  if [[ "${verbose}" -ge 1 ]]; then
    program_info
    print_usage
  fi
  
  if [[ "${verbose}" -ge 7 ]]; then
    print_arguments
  fi
  
  validate_inputs
  initialize_vars

  create_directories "${@}"
  check_gain_format
  update_adoc
  
  if [[ "${verbose}" -ge 1 ]]; then
    echo -e "Looking for files in '${vars[movie_dir]}/' for up to ${vars[max_minutes]} minutes\n"
    howto_stop
  fi

  mic_counter=0

  while (( $(echo "$SECONDS < $max_seconds" | bc) )) ; do
    new_files=($(get_new_files "${vars[movie_dir]}" ".${movie_ext}"))
# #     printf "'%s'\n" "${new_files[@]}" ; exit  ### TESTING

    for fn in "${new_files[@]}" ; do
      # Does the file end with .eer?
      if [[ "$fn" == *."${movie_ext}" ]]; then 
        parse_filename
    
        # Check termination flag
        if [[ "$kill_all_humans" == false ]]; then 
          check_new_tilt_series
          motioncor2_serial "${fn}"
          ctffind4_serial
        else
          break
        fi
#       
#       # TESTING
#       else
#         echo "$fn : doesn't end in '.${movie_ext}'"
#         exit
      fi
      # End movie IF-THEN
    done
    # End new-file loop
    
    # Check termination flag
    if [[ "$kill_all_humans" == true ]]; then 
      break
    fi
    
    # Checks every N seconds when we've run out of files
    sleep "${vars[search_interval]}"
  done
  # End while loop
  
  # Close last tomogram list
  check_time
  compute_tomogram
  summary_info
}
# End main()

function parse_command_line() {
###############################################################################
#   Function:
#     Parses command line
#   
#   Passed arguments:
#     ${@} : command-line arguments
#   
#   Global variables:
#     OPTION_SEP : (from argumentparser_dynamic.sh) hopefully-unique separator for variable fields
#     original_vars : non-associative array, before cleaning
#     var_sequence : associative array, maintaining the order of the variables
#     commandline_args : command-line arguments, may be modified
#     vars : final options array
#     ARGS : command-line arguments not accounted for as options will be here
#     verbose : shortened copy of vars[verbosity]
#   
###############################################################################
  
  add_section "INPUT MOVIE SETTINGS" "One of these directories is required."
  add_argument "eer_dir" "" "Input EER directory" "ANY"
  add_argument "mrc_dir" "" "Input MRC movie stack directory" "ANY"
  add_argument "tif_dir" "" "Input TIFF movie stack directory" "ANY"
  
  add_section "GLOBAL SETTINGS" "These settings affect multiple steps."
  add_argument "outdir" "${outdir}" "Output directory" "ANY"
  add_argument "mdoc_dir" "" "Input MDOC directory, will be copied to reconstruction directory" "ANY"
  add_argument "mdoc_file" "" "Single input example MDOC file, to extract pixel size, etc." "ANY"
  add_argument "apix" "${apix}" "Pixel size, A/px" "FLOAT"
  add_argument "verbosity" "${verbosity}" "Verbosity level (0..8) (3 or 2 recommended for testing mode)" "INT"
  add_argument "restore_movies" "false" "Move already-processed movies from output directory to input directory" "BOOL"
  add_argument "testing" "false" "Testing flag" "BOOL"
  add_argument "overwrite" "false" "Flag to overwrite pre-existing output directory" "BOOL"
  add_argument "log" "${log_file}" "Output log file (not used in testing mode)" "ANY"
  add_argument "max_minutes" "${max_minutes}" "Maximum run time, minutes" "INT"
  add_argument "kv" "${SNARTOMO_VOLTAGE}" "Voltage, kV" "FLOAT"
  add_argument "gpus" "${gpus}" "GPU to use (only single GPU supported in Classic mode)" "ANY"
  add_argument "no_redo3d" "false" "Flag to NOT overwrite pre-existing 3D reconstructions" "BOOL"
  add_argument "denoise_gpu" "${DENOISE_GPU}" "Flag to denoise using GPUs" "BOOL"

  add_section "ADVANCED SETTINGS" "These settings will rarely need to be changed."
  add_argument "search_interval" "${SNARTOMO_INTERVAL}" "Interval to check for new micrographs, seconds" "INT"
  add_argument "min_frames" "${SNARTOMO_MINFRAMES}" "Minimum number of frames (EERs only) before warning" "INT"
  add_argument "max_frames" "${SNARTOMO_MAXFRAMES}" "Maximum number of frames (EERs only) before warning" "INT"
  add_argument "temp_local" "${SNARTOMO_LOCAL}" "Directory to copy EER files locally" "ANY"
  add_argument "eer_local" "${CP_EER_LOCAL}" "Flag to temporarily copy EER files locally" "BOOL"
  add_argument "eer_latency" "${SNARTOMO_EER_WAIT}" "Maximum header read time before micrograph is copied locally" "FLOAT"
  add_argument "temp_wait" "${SNARTOMO_WAIT_TIME}" "How long to wait (seconds) for MotionCor2 or CTFFIND4 /tmp files to be removed" "FLOAT"
  add_argument "debug" "false" "Flag for debugging" "BOOL"
  
  # MotionCor2
  add_section "MOTIONCOR2 SETTINGS" "Settings for motion-correction."
  add_argument "frame_file" "${frame_file}" "Input MotionCor2 frame file" "ANY"
  add_argument "gain_file" "" "Input gain file" "ANY"
  add_argument "no_gain" "false" "Flag when no gain file is to be used" "BOOL"
  add_argument "motioncor_exe" "${MOTIONCOR2_EXE}" "MotionCor2 executable" "ANY"
  add_argument "do_dosewt" "false" "Flag to perform dose-weighting" "BOOL"
  add_argument "mcor_patches" "${SNARTOMO_MC2_PATCH}" "Number of patches in x y, delimited by spaces" "ANY"
  add_argument "do_outstack" "false" "Flag to write aligned stacks" "BOOL"
  add_argument "do_splitsum" "false" "Flag to split frames into even & odd half-sets" "BOOL"
  add_argument "split_sum" "${SplitSum}" "(DEPRECATED) Split frames into even & odd half-sets (0: no, 1: yes)" "INT"
  add_argument "reffrm" "${reffrm}" "Reference frame (0: first, 1: middle)" "INT"

  # CTFFIND
  add_section "CTFFIND4 SETTINGS" "Settings for CTF estimation."
  add_argument "ctffind_dir" "${CTFFIND4_BIN}" "CTFFIND executable directory" "ANY"
  add_argument "cs" "${SNARTOMO_CTF_CS}" "Spherical aberration constant (F20: 2.0, Krios: 2.7)" "FLOAT"
  add_argument "ac" "${SNARTOMO_AC}" "Amplitude contrast (0.07-0.1 for cryo data, 0.14-0.2 for neg.stain data)" "FLOAT"
  add_argument "box" "${SNARTOMO_CTF_BOXSIZE}" "Tile size for power-spectrum calculation" "INT"
  add_argument "res_lo" "${SNARTOMO_CTF_RESLO}" "Low-resolution limit for CTF fitting, Angstroms" "FLOAT"
  add_argument "res_hi" "${SNARTOMO_CTF_RESHI}" "High-resolution limit for CTF fitting, Angstroms" "FLOAT"
  add_argument "df_lo" "${SNARTOMO_CTF_DFLO}" "Minimum defocus value to consider during fitting, Angstroms" "FLOAT"
  add_argument "df_hi" "${SNARTOMO_CTF_DFHI}" "Maximum defocus value to consider during fitting, Angstroms" "FLOAT"
  add_argument "df_step" "${SNARTOMO_DF_STEP}" "Defocus search step during fitting, Angstroms" "FLOAT"
  add_argument "ast_step" "${SNARTOMO_CTF_DAST}" "Astigmatism search step during fitting, Angstroms" "FLOAT"
  add_argument "ctf1d_dpi" "$ctf1d_dpi" "Resolution (dpi) of PNG of 1D CTF profile" "INT"
  add_argument "ctfplot_first" "$ctfplot_first" "Plots first CTF data for first N images in tilt series" "INT"

  # JANNI
  add_section "JANNI SETTINGS" "Settings for JANNI denoise."
  add_argument "do_janni" "false" "Denoise micrographs using JANNI" "BOOL"
  add_argument "janni_model" "${JANNI_MODEL}" "JANNI 'h5' model file" "ANY"
  add_argument "janni_batch" "${SNARTOMO_JANNI_BATCH}" "Number of patches predicted in parallel" "INT"
  add_argument "janni_overlap" "${SNARTOMO_JANNI_OVERLAP}" "Overlap between patches, pixels" "INT"
  add_argument "janni_env" "${JANNI_ENV}" "JANNI conda environment" "ANY"

  # DoseDiscriminator
  add_section "DOSEDISCRIMINATOR SETTINGS" "Settings for dose-fitting."
  add_argument "dosefit_min" "${SNARTOMO_DOSEFIT_MIN}" "Minimum dose rate allowed, as a fraction of maximum dose rate" "FLOAT"
  add_argument "dosefit_resid" "${SNARTOMO_DOSEFIT_RESID}" "Maximum residual during dose-fitting, as a fraction of maximum dose rate" "FLOAT"
  add_argument "dosefit_verbose" "${dosefit_verbose}" "Verbosity level for dose-fitting log file (0..8)" "ANY"

  # TOPAZ
  add_section "TOPAZ SETTINGS" "Settings for denoising."
  add_argument "do_topaz" "false" "Denoise micrographs using Topaz" "BOOL"
  add_argument "topaz_patch" "${SNARTOMO_TOPAZ_PATCH}" "Patch size for Topaz denoising" "INT"
  add_argument "topaz_time" "${SNARTOMO_TOPAZ_TIME}" "Maximum duration, Topaz sometimes hangs" "ANY"
  add_argument "topaz_env" "${TOPAZ_ENV}" "Topaz conda environment" "ANY"

  # Ruotnocon contour removal
  add_section "RUOTNOCON SETTINGS" "Settings for contour removal in IMOD reconstruction."
  add_argument "do_ruotnocon" "false" "Remove contours based on residual" "BOOL"
  add_argument "ruotnocon_sd" "${SNARTOMO_RUOTNOCON_SD}" "Contours with residuals greater than this multiple of sigma will be removed" "FLOAT"

  # IMOD
  add_section "IMOD SETTINGS" "Settings for IMOD: restacking and optional eTomo reconstruction."
  add_argument "imod_dir" "${IMOD_BIN}" "IMOD executable directory" "ANY"
  add_argument "batch_directive" "" "IMOD eTomo batch directive file" "ANY"

  # Laudiseron micrograph removal
  add_section "LAUDISERON SETTINGS" "Settings for micrograph removal in IMOD reconstruction."
  add_argument "do_laudiseron" "false" "Remove micrographs based on alignment residual" "BOOL"
  add_argument "laudiseron_sd" "3.0" "Micrographs with residuals greater than this multiple of sigma will be removed" "FLOAT"

  # AreTomo parameters
  add_section "ARETOMO SETTINGS" "Reconstruction will be computed either with AreTomo (default) or IMOD."
  add_argument "aretomo_exe" "${ARETOMO_EXE}" "AreTomo executable" "ANY"
  add_argument "are_bin" "${SNARTOMO_BINNING}" "Binning factor for reconstruction" "INT"
  add_argument "vol_zdim" "${SNARTOMO_VOL_ZDIM}" "z-dimension for volume" "INT"
  add_argument "rec_zdim" "${SNARTOMO_REC_ZDIM}" "z-dimension for 3D reconstruction" "INT"
  add_argument "tilt_axis" "${SNARTOMO_TILT_AXIS}" "Estimate for tilt-axis direction, degrees" "FLOAT"
  add_argument "dark_tol" "${SNARTOMO_DARKTOL}" "Tolerance for dark images (0.0-1.0)" "FLOAT"
  add_argument "tilt_cor" "${SNARTOMO_TILTCOR}" "Tilt-correction flag (1: yes, 0: no)" "INT"
  add_argument "bp_method" "${SNARTOMO_BP_METHOD}" "Reconstruction method (1: weighted backprojection, 0: SART)" "INT"
  add_argument "flip_vol" "${SNARTOMO_FLIPVOL}" "Flag to flip coordinates axes (1: yes, 0: no)" "INT"
  add_argument "transfile" "${SNARTOMO_TRANSFILE}" "Flag to generate IMOD XF files (1: yes, 0: no)" "INT"
  add_argument "are_patches" "${SNARTOMO_ARETOMO_PATCH}" "Number of patches in x & y (delimited by spaces)" "ANY"
  add_argument "are_time" "${SNARTOMO_ARETOMO_TIME}" "Maximum duration (AreTomo sometimes hangs)" "ANY"

  # IsoNet
  add_section "ISONET SETTINGS" "Settings for IsoNet deconvolution."
  add_argument "do_deconvolute" "false" "Deconvolute using IsoNet" "BOOL"
  add_argument "snr_falloff" "${SNARTOMO_SNRFALLOFF}" "Signal-to-noise falloff" "FLOAT"
  add_argument "isonet_env" "${ISONET_ENV}" "IsoNet conda environment" "ANY"

  dynamic_parser "${@}"
  
  # We're going to use this variable a lot
  verbose="${vars[verbosity]}"
  
  # For PACE-compatibility
  gpu_num="${vars[gpus]}"
}

function add_argument() {
###############################################################################
#   Function:
#     Adds single argument
#   
#   Add arguments with the following form:
#     add_argument "OPTION_NAME" "DEFAULT_VALUE" "OPTION DESCRIPTION" "OPTION_TYPE"
#   Quotes are required.
#   
#   Valid option types are:
#     INT : integer
#     UINT : unsigned integer
#     FLOAT : floating point
#     BOOL : Boolean
#     FILE : filename, must exist
#     DIR : directory, must exist
#     REGEX : integer
#     ANY : arbitrary
#   Unassigned options will be assigned to array ARGS.
#   
#   Global variables:
#     original_vars : non-associative array
#     var_sequence : associative array, maintaining the order of the variables
#     argument_idx : index for ARGUMENTS key
#   
###############################################################################
        
    local key=$1
    local default=$2
    local description=$3
    local type=$4
    
    original_vars[${key}]="${default} ${OPTION_SEP} ${description} ${OPTION_SEP} ${type}"
    var_sequence+=(${key})
    
    # Remember index for "arguments" key
    if [[ ${key} = ARGUMENTS ]]; then
        argument_idx=$(( ${#var_sequence[@]} - 1 ))
    fi
}

function print_arguments() {
    regex_split="^\(.*\)${OPTION_SEP}\(.*\)${OPTION_SEP}\(.*\)$"
    local section_counter=0
    
    echo -e "\n=== Input Settings, Value, Description ==="

    # Suppress keys
    for var_idx in "${!var_sequence[@]}"
    do
        # Check if there are any remaining section headings
        if [[ "${#section_vars[@]}" -gt "${section_counter}" ]]; then
            # Check if next section index is current var index
            if [[ "${section_sequence[${section_counter}]}" == "${var_idx}" ]]; then
                section_name=`echo ${section_vars[${var_idx}]} | awk -F" ${OPTION_SEP} " '{print $1}'`
                echo -e "${section_name}"
                let "section_counter++"
            fi
        fi
        
        key="${var_sequence[${var_idx}]}"
        description="$(echo "${original_vars[${key}]}" | sed "s|${regex_split}|\2|g")"
        echo -e "  --${key} \t${vars[${key}]} \t${description}"
    done
}

function add_section() {
###############################################################################
#   Function:
#     Adds single argument
#   
#   Add sections with the following form:
#     add section "SECTION NAME" "SECTION DESCRIPTION"
#   Quotes are required.
#   
#   Global variables:
#     var_sequence : associative array, maintaining the order of the variables
#     section_vars : non-associative array
#     section_sequence : records position of the sections
#   
###############################################################################
    
    # Positional arguments
    local section_name=$1
    local description=$2
    
    local curr_idx=${#var_sequence[@]}
    local curr_str="${section_name} ${OPTION_SEP} ${description}"
    
    # Update arrays
    section_sequence+=(${curr_idx})
    section_vars[${curr_idx}]="${curr_str}"
}

function check_env() {
###############################################################################
#   Functions:
#     Checks whether environmental variable SNARTOMO_DIR is set
#     Sources shared functions from central SNARTomo directory
#     
#   Calls functions:
#     check_vars
#   
#   Global variables:
#     do_pace
#     shared_libs
#     
###############################################################################

  if [[ "${SNARTOMO_DIR}" == "" ]]; then
    echo -e "\nERROR!! Environmental variable 'SNARTOMO_DIR' undefined!"
    echo      "  Set variable with: export SNARTOMO_DIR=<path_to_snartomo_files>"
    echo -e   "  Exiting...\n"
    exit
  else
    source "${SNARTOMO_DIR}/${shared_libs}"
    source "${SNARTOMO_DIR}/argumentparser_dynamic.sh"
    
    check_vars
    
    if [[ "${do_pace}" == true ]]; then
      source "${SNARTOMO_DIR}/gpu_resources.bash"
    fi
  fi
}

function initialize_vars() {
###############################################################################
#   Function:
#     Initializes data structures
#   
#   Global variables:
#     old_state
#     new_state
#     prev_name
#     mcorr_mic_array
#     denoise_array
#     stripped_angle_array
#     ctf_stk_array
#     tomo_counter
#     kill_all_humans
#     max_seconds
#
###############################################################################
  
  old_state=.old_state
  new_state=.new_state
  prev_name=""
  
  declare -A mcorr_mic_array=()
  declare -A denoise_array=()
  declare -A stripped_angle_array=()
  declare -A ctf_stk_array=()
  
  tomo_counter=0
  kill_all_humans=false
  
  # Create a blank file of previously-known micrographs
  rm $old_state 2> /dev/null
  touch $old_state
  
  max_seconds=`echo "${vars[max_minutes]}"*60 | bc`
}

function get_new_files() {
###############################################################################
#   Function:
#     Splits directory name and extension from filename
#   
#   Adapted from Markus Stabrin
#   
#   Global variables:
#     old_state
#     new_state
#   Local variables:
#     $1 : input directory
#     $2 : file extension
###############################################################################

    local input_dir=${1}
    local suffix=${2}

    ls -tr ${input_dir}/*${suffix} > "${new_state}" 2>/dev/null
    comm -13 "${old_state}" "${new_state}" 2>/dev/null
    cp "${new_state}" "${old_state}"
}

function parse_filename() {
###############################################################################
#   Function:
#     Parses filenames
#   
#   Global variables:
#     vars
#     stem_movie (OUTPUT)
#     fn
#     cor_mic
#     dns_mic
#     outdir
#     mc2_logs
#     stem_mrc
#     angle
#     tilt_idx
#     tomo_name
#     kill_all_humans
#     movie_ext
#     found_msg
#     
###############################################################################
  
  # Cut directory name and extension (last period-delimited string)
  stem_movie=$(basename $fn | rev | cut -d. -f2- | rev)
  cor_mic="${vars[outdir]}/${micdir}/${stem_movie}_mic.mrc"
  dns_mic="${vars[outdir]}/${denoisedir}/${stem_movie}_mic.mrc"
  ali_out="${vars[outdir]}/${micdir}/${mc2_logs}/${stem_movie}_mic.out"

  # Remove extension (last period-delimited string)
  stem_mrc=$(file_stem "$cor_mic")
  # (Syntax adapted from https://unix.stackexchange.com/a/64673)
  
  # Remove last two underscore-delimited strings (${date}_mic)
  local wo_date=`echo $stem_mrc | rev | cut -d_ -f3- | rev`
  
  # Remove next underscore-delimited string (angle)
  angle=$(echo $wo_date | rev | cut -d_ -f1 | rev)
  
  # Remove next underscore-delimited string (tilt-series index)
  tilt_idx=$(echo $wo_date | rev | cut -d_ -f2 | rev | bc)
  # Using bc to convert to number: https://stackoverflow.com/a/11268537

  # Remove remaining underscore-delimited string (tomogram name)
  tomo_name=`echo $wo_date | rev | cut -d_ -f3- | rev`
  
  # If the filename is illegal, the index is possibly not an integer (https://stackoverflow.com/a/19116862)
  if ! [[ $tilt_idx =~ ^[-+]?[0-9]+$ ]] ; then
    if [[ "$verbose" -ge 2 ]]; then
      echo -e "\nWARNING! Filename '$fn' is being parsed incorrectly."
      echo      "  Make sure that you are using the correct naming convention."
      echo      "  Maybe you're simply terminating the run."
      
      echo -e "\nTERMINATING! (after next reconstruction)"
      date
      echo
    fi
    
    # Termination flag
    kill_all_humans=true
  else
    # Update number of remaining files
    if [[ "$verbose" -ge 4 ]]; then
      # Adapted from https://stackoverflow.com/a/33891876/3361621
      remaining_files=$(ls 2> /dev/null -Ubad -- ${vars[movie_dir]}/*.${movie_ext} | wc -w)
      let "mic_counter++"
      
      if [[ "${vars[testing]}" == false ]]; then
        found_msg="    Found $fn     \tmicrograph #${mic_counter}, ${remaining_files} remaining"
      else
        found_msg="    Found $fn     \tmicrograph #${mic_counter} of ${remaining_files}"
      fi
    fi
  fi
  # End illegal-filename IF-THEN
  
  if [[ "$verbose" -ge 7 ]]; then
    echo      "    Filename: '$fn'"
    echo      "    MRC w/o extension: '$stem_mrc'"
    echo      "    Should remove date: '$wo_date'"
    echo      "    Should be angle: '$angle'"
    echo      "    Should be tilt index: '$tilt_idx'"
    echo      "    Tilt series stem: '$tomo_name'"
    echo -e   "    Termination flag: '$kill_all_humans'\n"
  fi
}

function move_micrograph() {
###############################################################################
#   Function:
#     Moves micrograph so that it isn't processed again
#   
#   Positional variables:
#     1) filename
#   
#   Global variables:
#     kill_all_humans
#     vars
#     verbose
#     rawdir
#     
###############################################################################
  
  fn=$1
  
  # Check termination flag
  if [[ "$kill_all_humans" == false ]]; then
#     echo "fn: ${fn}"  # TESTING
      
    # Sanity check
    if ! [[ "$fn" == *."${movie_ext}" ]]; then 
      echo    "WARNING: Filename '$fn' doesn't end in '.${movie_ext}'"
      echo -e "         Continuing...\n"
    fi
    
#     # Move micrograph to output directory so that it isn't processed again
#     if [[ "${vars[testing]}" == false ]]; then
      # In case EER format and was copied locally, use original directory explicitly
      local orig_movie="${vars[movie_dir]}/$(basename $fn)"
      
      if [[ "$verbose" -ge 5 ]]; then
        echo -e "\n    $(mv -v ${orig_movie} ${vars[outdir]}/${rawdir}/)\n"
      else
        mv ${orig_movie} ${vars[outdir]}/${rawdir}/
      fi
#     
#     else
#       vprint "    TESTING mv -v $fn "${vars[outdir]}"/$rawdir/" "5+"
#     fi
#     # End testing IF-THEN
#     
  fi
  # End continue IF-THEN
}

function check_new_tilt_series() {
###############################################################################
#   Function:
#     1) Checks for up tilt series
#     2) Updates info for current tilt series
#   
#   Global variables:
#     prev_name
#     tomo_name
#     verbose
#     found_msg
#     vars : command-line arguments
#     mcorr_mic_array
#     denoise_array
#     ctf_stk_array
#     tilt_idx
#     cor_mic
#     stripped_angle_array
#     angle
#     
###############################################################################
  
  # Check if new tomogram
  if [[ "$prev_name" != "$tomo_name"  ]]; then
    if [[ "$prev_name" != "" ]]; then
      # Write restack images and compute tomogram
      compute_tomogram
    fi
    
    if [[ "$verbose" -ge 3 ]]; then
      if [[ ! -z "$tomo_name" ]]; then
        echo "  Found multiple micrographs starting with '$tomo_name*', possibly tilt series"
      fi
    fi
  fi
  # End new-tomogram IF-THEN
  
  # The indentation looks better if I don't print the found-micrograph message until I've checked for new tilt series
  if [[ "$verbose" -ge 4 ]]; then
    echo -e "${found_msg}"
  fi

  # Append micrograph filename to array
  if [[ "${vars[do_janni]}" == true ]] || [[ "${vars[do_topaz]}" == true ]]; then
    denoise_array[$tilt_idx]=$dns_mic
  fi
  
  mcorr_mic_array[$tilt_idx]=$cor_mic
  ctf_stk_array[$tilt_idx]=$(mic_to_ctf "$cor_mic")
  
  # Angle array (with same index keys) will be used to sort
  stripped_angle_array[${tilt_idx}]="${angle}"
  
  # Update
  prev_name=$tomo_name
}

function motioncor2_serial() {
###############################################################################
#   Function:
#     Wrapper for MotionCor2
#     Default behavior is to NOT overwrite pre-existing outputs.
#   
#   Positional variables:
#     1) movie filename
#     
#   Calls functions:
#     check_frames
#     wait_for_file
#     run_motioncor
#     remove_local
#   
#   Global variables:
#     kill_all_humans
#     vars
#     cor_mic
#     movie_ext
#     verbose
#     remaining_files
#     ali_out
#     fn (OUTPUT)
#     gpu_num
#     
###############################################################################
  
  fn=$1
#   
  # Check termination flag
  if [[ "$kill_all_humans" == false ]]; then
    if [[ "${vars[testing]}" == false ]]; then
      # Check if output already exists
      if [[ ! -e $cor_mic ]]; then
        # Check number of frames
        if [[ "${movie_ext}" == "eer" ]] ; then
          check_frames
        fi
        
        # If someone else owns /tmp/MotionCor2_FreeGpus.txt, MotionCor will be unhappy
        wait_for_file "/tmp/MotionCor2_FreeGpus.txt"
        
        # Update number of remaining files
        if [[ "$verbose" -ge 5 ]]; then
          echo "    Running MotionCor2 on '$fn', micrograph #${mic_counter}, ${remaining_files} remaining"
          
          # Show command line without running MotionCor
          run_motioncor "${fn}" "${gpu_num}"
        fi
        
        local mc2_cmd=$(run_motioncor "${fn}" "$gpu_num")
        
        # Actually run it
        if [[ "$verbose" -le 6 ]]; then
          # Suppress warning: "TIFFReadDirectory: Warning, Unknown field with tag 65001 (0xfde9) encountered."
          ${mc2_cmd} 2> /dev/null 1> $ali_out
        
        # Full output
        else
          ${mc2_cmd} 2>&1 | tee $ali_out
        fi
          
        # Remove temp file
        local mc2_tempfile="/tmp/MotionCor2_FreeGpus.txt"
        \rm -r ${mc2_tempfile} 2> /dev/null
        
        # Sanity check
        if [[ ! -f "$cor_mic" ]]; then
          echo    "    WARNING! MotionCor2 output $cor_mic does not exist!"
          echo -e "             Continuing...\n"
          
          return
        
        # Output exists
        else
          # Print notable MotionCor2 information to screen
          if [[ "$verbose" -ge 7 ]]; then
            echo ""
            echo "    Finished MotionCor2 on micrograph $fn"
            echo "    $(grep 'Total time' $ali_out)"
            echo ""
          fi
          
          move_micrograph "${fn}"
        
          # Remove locally-copied EER file (make sure it's in the temp directory and not the original)
          remove_local "$fn"
        fi
        # End output-exists IF-THEN
      
      # If pre-exising output
      else
        if [[ "$verbose" -ge 4 ]] ; then
          echo    "    WARNING: MotionCor2 output $cor_mic already exists"
          echo -e "      Skipping...\n"
        fi
        
        move_micrograph "${fn}"
      fi
      # End preexisting-file IF-THEN
    
    # Testing
    else
      if [[ "$verbose" -ge 5 ]]; then
        run_motioncor "${fn}" "${gpu_num}"
      fi
      
      if [[ ! -e $cor_mic ]]; then
        touch $cor_mic
      else
        if [[ "$verbose" -ge 4 ]] ; then
          echo    "    WARNING: MotionCor2 output $cor_mic already exists"
          echo -e "      Skipping...\n"
        fi
      fi
      # End preexisting-file IF-THEN
    fi
    # End testing mode
  fi
  # End continue IF-THEN
}

function ctffind4_serial() {
###############################################################################
#   Function:
#     1) Wrapper for CTFFIND4
#     2) Generates 1D profile
#   
#   Calls functions:
#     ctffind_common
#     vprint
#   
#   Global variables:
#     ctf_out
#     vars
#     stem_movie
#     kill_all_humans
#     ctf_mrc
#     warn_msg
#     verbose
#     
###############################################################################

  ctf_out="${vars[outdir]}/${ctfdir}/${stem_movie}_ctf.out"
  ctf_mrc="${vars[outdir]}/${ctfdir}/${stem_movie}_ctf.mrc"
  
  # Check termination flag
  if [[ "$kill_all_humans" == false ]]; then
    # Sanity check: Look for existing CTFFIND output
    if [[ ! -e $ctf_mrc ]]; then
      ctffind_common "${stem_movie}"
      
      # Print only one warning message per micrograph
      if [[ "${warn_msg}" != "" ]]; then
        echo    "    ${warn_msg}"
        echo -e "             Continuing...\n"
      else
        vprint "" "5+"
      fi
    else
      if [[ "$verbose" -ge 4 ]] ; then
        echo    "    WARNING: CTFFIND4 output $ctf_mrc already exists"
        echo -e "      Skipping...\n"
      fi
    fi
    # End preexisting-file IF-THEN
  fi
  # End continue IF-THEN
}

function compute_tomogram() {
###############################################################################
#   Function:
#     1) Run IMOD's newstack command
#     2) Compute tomographic recontruction with AreTomo
#     3) Closes and re-initializes arrays
#     
#     Default behavior is to OVERWRITE pre-existing outputs.
#   
#   Calls functions:
#     write_angles_lists
#     write_tomo_ctfs
#     janni_denoise
#     topaz_denoise
#     imod_restack
#     wrapper_aretomo
#     wrapper_etomo
#   
#   Global variables:
#     vars
#     mcorr_mic_array
#     tomo_dir
#     new_mdoc (OUTPUT)
#     good_angles_file
#     recdir
#     prev_name
#     tomo_root (OUTPUT)
#     tomo_dns_dir
#     micdir
#     tomogram_3d
#     
###############################################################################
  
  # Create subdirectory for each tomogram (even in testing mode)
  tomo_dir="${recdir}/${prev_name}"
  
  if [[ "$verbose" -ge 2 ]]; then
    echo
    mkdir -pv "${vars[outdir]}/${tomo_dir}" | sed 's/^/  /'
  else
    mkdir -p "${vars[outdir]}/${tomo_dir}"
  fi
  
  # Output files
  tomo_root="${vars[outdir]}/${tomo_dir}/${prev_name}"
  local cor_ext="_mic.mrc"
  
  # Check length of array (https://unix.stackexchange.com/a/193042)
  local num_mics=${#mcorr_mic_array[@]}
  if [[ "$num_mics" -eq 1 ]]; then
    if [[ "$verbose" -ge 2 ]]; then
      echo "  WARNING! Found only 1 micrograph of form '$prev_name*' ($(basename $fn))"
      echo "    Skipping tomogram reconstruction..."
    fi
    return
  fi
  
  if [[ "${vars[do_janni]}" == true ]] || [[ "${vars[do_topaz]}" == true ]]; then
    # Create denoising directory
    local tomo_mic_dir="${vars[outdir]}/${tomo_dir}/${temp_dir}"
    tomo_dns_dir="${vars[outdir]}/${tomo_dir}/${temp_dir}/${dir2denoise}"
    mkdir ${tomo_mic_dir} ${tomo_dns_dir} 2> /dev/null
  fi

  # Find MDOC file
  if [[ "${vars[mdoc_dir]}" != "" ]] ; then
    local last_mic="$(basename ${mcorr_mic_array[-1]%_mic.mrc})"
    local found_mdoc=$(grep -l $last_mic ${vars[mdoc_dir]}/*.mdoc 2> /dev/null)
    
    if [[ $found_mdoc != "" ]] ; then
      local mdoc_base=$(basename $found_mdoc)
      local mdoc_copy="${vars[outdir]}/${tomo_dir}/${mdoc_base%.mrc.mdoc}_orig.mrc.mdoc"
      new_mdoc="${vars[outdir]}/${tomo_dir}/${mdoc_base}"
      local temp_mdoc_dir="${vars[outdir]}/${tomo_dir}/tmp_mdoc"
      
      if [[ "$verbose" -ge 2 ]]; then
        echo -e "\n  Copied $(cp -v --preserve=timestamps ${found_mdoc} ${mdoc_copy})"
      else
        cp --preserve=timestamps ${found_mdoc} ${mdoc_copy}
      fi
  
      # Parse MDOC (awk notation from Tat)
      mapfile -t mdoc_angle_array < <( grep "TiltAngle" "${mdoc_copy}" | awk '{print $3}' | sed 's/\r//' )
      mapfile -t new_subframe_array < <( grep "SubFramePath" "${mdoc_copy}" | awk '{print $3}' | sed 's/\r//' )
      mapfile -t dose_rate_array < <( grep "DoseRate" "${mdoc_copy}" | awk '{print $3}' | sed 's/\r//' )
      
      # Fit dose to cosine function
      dose_fit "${prev_name}" "${mdoc_copy}"
      
      # Write MDOC file with remaining micrographs
      clean_up_mdoc "${mdoc_copy}" "${new_mdoc}" "$temp_mdoc_dir"
    
    # Not using MDOC
    else
      if [[ "$verbose" -ge 2 ]]; then
        echo "  WARNING! Didn't find entry MDOC in directory '${vars[mdoc_dir]}'"
      fi
      
      good_angles_file="${tomo_root}_goodangles.txt"
    fi
    # End found-MDOC IF-THEN
  else
    new_mdoc=""
  fi
  
  write_angles_lists
  
  # Plot CTF data
  plot_tomo_ctfs "${found_mdoc}"
  
  # Optionally denoise
  if [[ "${vars[do_janni]}" == true ]] || [[ "${vars[do_topaz]}" == true ]] ; then
    # Move to temp directory
    if [[ "${vars[testing]}" == false ]] ; then
      for idx in ${!mcorr_mic_array[@]} ; do
        mv ${mcorr_mic_array[$idx]} ${tomo_mic_dir}/
      done
    fi
    
    if [[ "${vars[do_janni]}" == true ]]; then
      denoise_wrapper "janni" "${tomo_mic_dir}" 
    elif [[ "${vars[do_topaz]}" == true ]]; then
      denoise_wrapper "topaz" "${tomo_mic_dir}" 
    fi
    
    # Move micrographs to final directory
    mv ${tomo_dns_dir}/*mic.mrc ${vars[outdir]}/${denoisedir}/ 2> /dev/null
    rmdir -p ${tomo_dns_dir} 2> /dev/null
    mv ${tomo_mic_dir}/*mic.mrc ${vars[outdir]}/${micdir}/ 2> /dev/null
  fi
    
  # Restack micrographs from lowest angle (most negative) to highest
  imod_restack
  
  if [[ "${vars[batch_directive]}" == "" ]]; then
    wrapper_aretomo "${num_mics}" "${vars[gpus]}"
  else
    # If splitting eTomo (laudiseron or ruotnocon)
    if [[ "${vars[do_ruotnocon]}" == true ]] || [[ "${vars[do_laudiseron]}" == true ]] ; then
      
      if [[ "${vars[do_laudiseron]}" == true ]] ; then
        wrapper_etomo "${prev_name}" "${ts_mics}" "true"  "-end 6"
      fi
      
      # If we ran laudiseron, we need to run eTomo again with the cleaned set of micrographs
      wrapper_etomo "${prev_name}" "${num_mics}" "false" "-end 6"
      
      if [[ "${vars[do_ruotnocon]}" == true ]] ; then
        ruotnocon_wrapper "${tomo_dir}" "${prev_name}"
      fi
      
      wrapper_etomo "${prev_name}" "${num_mics}" "false" "-start 6"
    else
      wrapper_etomo "${prev_name}" "${num_mics}" "false" ""
    fi
    # End splitting-eTomo IF-THEN
  fi
  # End AreTomo-vs-eTomo IF-THEN

  if [[ -f "$tomogram_3d" ]]; then
    if [[ "${vars[do_deconvolute]}" == true ]]; then
      deconvolute_wrapper "${vars[outdir]}/${tomo_dir}" "${new_mdoc}"
    fi
    
    get_central_slice ${tomogram_3d}
  fi
  # End tomogram-exists IF-THEN
    
  # We might need these arrays multiple times if we run laudiseron, so don't delete them until now
  unset mcorr_mic_array
  unset denoise_array
  unset stripped_angle_array
  
  # Increment tomogram counter
  let "tomo_counter++"
}

function check_time() {
###############################################################################
#   Function:
#     Checks elapsed time
#   
###############################################################################
  
  if [[ "$kill_all_humans" == false ]]; then 
    echo -e "\nProgram timed out at `date`" "1+"
    kill_all_humans=true
  fi
}

function summary_info() {
###############################################################################
#   Function:
#     Prints summary info
#   
#   Global variables:
#     verbose
#     tomo_counter
#     remaining_files
#     testing
#   
###############################################################################
  
  # Remove temp directory if copying EERs locally
  clean_local_dir "temp_local"
  
  if [[ "$verbose" -ge 1 ]]; then
    echo
    echo "Found $tomo_counter tilt series in total"
    echo "DONE!"
    date
    echo
  fi
      
  # Check if there are remaining files (excluding the dummy file)
  let "remaining_files--"
  if [[ "$verbose" -ge 2 ]] && [[ "${vars[testing]}" == false ]] ; then
    if [[ "$remaining_files" -ge 2 ]]; then
      echo "WARNING! There are ${remaining_files} movie files remaining (excluding the dummy file)"
      echo "         Are you sure you know what your (sic.) doing?"
      echo ""
    fi
  fi
}

function DUMMY_FUNCTION() {
###############################################################################
#   Function:
#     FUNCTION
#   
#   Positional variables:
#   
#   Calls functions:
#   
#   Global variables:
#   
###############################################################################
  
  return
}

###############################################################################

main "$@"
# "$@" passes command line parameters to main() (https://unix.stackexchange.com/a/449508)

exit
